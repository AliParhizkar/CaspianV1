using System.Text;
using Caspian.Common;
using Caspian.Common.Service;
using Caspian.Common.Extension;

namespace Caspian.Engine.Service
{
    public class ActivityService : BaseService<Activity>
    {
        public ActivityService(IServiceProvider provider)
            :base(provider)
        {
            RuleFor(t => t.Title).Required().UniqAsync("فعالیتی با این عنوان در سیستم ثبت شده است");
            RuleFor(t => t.Name).Required().UniqAsync("فعالیتی با این نام در سیستم ثبت شده است")
                .Custom(t => t.Name.IsValidIdentifire(), "لطفا فقط از اعداد و حروف لاتین برای نامگذاری استفاده نمایید.");
        }

        public async Task<string> GetCodebehindAsync(int activityId)
        {
            var str = new StringBuilder();
            var activity = await SingleAsync(activityId);
            str.Append("/// This code is generated by caspian generator and can not be changed\n\n");
            str.Append("using Caspian.Workflow;\n\n");
            str.Append("namespace Caspian.Dynamic.Workflow\n{\n");
            var name = activity.Name;
            if (!name.EndsWith("Activity", StringComparison.OrdinalIgnoreCase))
                name = name + "Activity";
            str.Append("\tpublic partial class " + name + ": UserActivity\n\t{\n");
            str.Append("\n\t}\n}");
            return str.ToString();
        }

        public async Task<string> GetSourceCodeAsync(int activityId, string basePath)
        {
            var str = new StringBuilder();
            var activity = await SingleAsync(activityId);
            if (activity.SourceCodeFileName.HasValue())
                return await File.ReadAllTextAsync(basePath + "/" + activity.SourceCodeFileName);
            str.Append("/// This code is generated by caspian generator and can not be changed\n\n");
            str.Append("using Caspian.Workflow;\n\n");
            str.Append("namespace Caspian.Dynamic.Workflow\n{\n");
            var name = activity.Name;
            if (!name.EndsWith("Activity", StringComparison.OrdinalIgnoreCase))
                name = name + "Activity";
            str.Append("\tpublic partial class " + name + ": UserActivity\n\t{\n");
            str.Append("\n\t}\n}");
            return str.ToString();
        }

        public void RemoverWorkflowActivities(int workflowId)
        {
            var activities = GetAll().Where(t => t.WorkflowId == workflowId);
            RemoveRange(activities);
        }

        public IQueryable<Activity> GetActivities(int workflowId)
        {
            return GetAll().Where(t => t.WorkflowId == workflowId);
        }

        public Connector GetConnector(Activity activity, object data, string action)
        {
            var list = activity.OutConnectors.Where(t => t.Title == action).ToList();
            if (list.Count == 1)
                return list[0];
            foreach (var connector in list)
            {
                var value1 = Convert.ToDecimal(data.GetMyValue(connector.FieldName));
                if (Compare(connector.CompareType.Value, value1, connector.Value.Value))
                    return connector;
            }
            throw new Exception("خطا:در حالت " + activity.Title + " شروط انشعاب درست ثبت نشده اند");
        }

        private bool Compare(CompareType comapre, decimal value1, decimal value2)
        {
            switch(comapre)
            {
                case CompareType.Equal:
                    return value1 == value2;
                case CompareType.GreaterThan:
                    return value1 > value2;
                case CompareType.GreaterThanOrEqual:
                    return value1 >= value2;
                case CompareType.LessThan:
                    return value1 < value2;
                case CompareType.LessThanOrEqual:
                    return value1 <= value2;
                case CompareType.NotEqual:
                    return value1 != value2;
                default:
                    throw new NotImplementedException("");
            }
        }
    }

    public static class CompareTypeExtenssion
    {
        public static string GetMathSign(this CompareType compareType)
        {
            switch (compareType)
            {
                case CompareType.Equal:
                    return " = ";
                case CompareType.GreaterThan:
                    return " > ";
                case CompareType.GreaterThanOrEqual:
                    return " ≥ ";
                case CompareType.LessThan:
                    return " < ";
                case CompareType.LessThanOrEqual:
                    return " ≤ ";
                case CompareType.NotEqual:
                    return " ≠ ";
                default:
                    return "";
            }
        }
    }

}
