@namespace Caspian.Report
@using Caspian.Common
@{
    var style = $"left:{Data.Left}px;top:{Data.Top}px";
}
<table style="@style" class="reportcontrol tablecontrol" cellpadding="0" cellspacing="0">
    <thead>
        <tr>
            <th style="width:15px;"></th>
            @{
                var index = 1;
            }
            @foreach (var cell in Data.HeaderCells)
            {
                var tempIndex = index;
                <th style="width:@(cell.Width)px;"></th>
                index++;
            }
        </tr>
    </thead>
    <tbody>
        @{
            var rowIndex = 1;
        }
        @foreach (var row in Data.Rows)
        {
            var tempRowIndex = rowIndex;
            <tr style="line-height:@(row.Height)px">
                @{
                    var colIndex = 1;
                }
                <td class="rowHeader" style="height:@(row.Height)px"></td>
                @foreach(var cell in row.Cells)
                {
                    var tempColIndex = colIndex;
                    var className = "";
                    if (Bound != null && Bound.Page.SelectedTable == this)
                        if (selectedCells.Any(t => t.Row.RowIndex == tempRowIndex && t.ColIndex == tempColIndex))
                            className = "cellselected";
                    if (cell.Hidden)
                        className += " hidden-cell";
                    <td colspan="@(cell.ColSpan)" rowspan="@(cell.RowSpan)" class="@(className)" @onmousedown="e => SelectTableCell(e.CtrlKey, cell)">@(cell.Text)</td>
                    colIndex++;
                }
            </tr>
            rowIndex++;
        }
    </tbody>
</table>

@code 
{
    IList<TableCell> selectedCells;
    ChangeKind? changeKind;
    int? changeColIndex, leftCellStartWidth, rightCellStartWidth, xStart, leftStart, difrentCurcer;

    int? changeRowIndex, heightStart, yStart;

    [Parameter]
    public Bound Bound { get; set; }

    [Parameter]
    public TableData Data { get; set; }

    public int TopStart { get; set; }

    #region Add or Remove Column and row
    void InsertRow(bool insertBefor, int index)
    {
        /// Insert column befor or after the selected row
        var row = new TableRow();
        for (var i = 1; i < Data.HeaderCells.Count; i++)
            row.Cells.Add(new TableCell(row));
        Data.Rows.Insert(insertBefor ? index : index - 1, row);
        UpdateRowAndColumnIndex();
    }

    void RemoveRow(int index)
    {
        Data.Rows.RemoveAt(index - 1);
        UpdateRowAndColumnIndex();
    }

    void InsertColumn(bool insertBefor, int index)
    {
        /// Insert column befor or after the selectd column
        var tempIndex = insertBefor ? index : index - 1;
        var head = Data.HeaderCells.ElementAt(index - 1);
        Data.HeaderCells.Insert(tempIndex, new HeaderCell() { Width = head.Width / 2 });
        head.Width = head.Width - head.Width / 2;
        foreach (var row in Data.Rows)
            row.Cells.Insert(tempIndex, new TableCell(row));
        UpdateRowAndColumnIndex();
    }

    void RemoveColumn(int index)
    {
        var headerCells = Data.HeaderCells;
        var curent = headerCells.ElementAt(index - 1);
        if (index == 1)
        {
            var next = headerCells.ElementAt(index);
            next.Width += curent.Width;
        }
        else
        {
            var pre = headerCells.ElementAt(index - 2);
            pre.Width += curent.Width;
        }
        foreach (var row in Data.Rows)
            row.Cells.RemoveAt(index - 1);
        headerCells.Remove(curent);
        UpdateRowAndColumnIndex();
    }

    void UpdateRowAndColumnIndex()
    {
        var rowIndex = 1;
        foreach (var row in Data.Rows)
        {
            row.RowIndex = rowIndex;
            var colIndex = 1;
            foreach (var cell in row.Cells)
            {
                cell.ColIndex = colIndex;
                colIndex++;
            }
            rowIndex++;
        }
    }
    #endregion

    #region Merge and unmerge
    public void UnmergeSelectedCell()
    {
        var selectedCell = selectedCells.Single();
        if (selectedCell.ColSpan > 1)
        {
            foreach(var cell in selectedCell.Row.Cells)
            {
                if (cell.ColIndex > selectedCell.ColIndex && cell.ColIndex <= selectedCell.ColIndex + selectedCell.ColSpan)
                    cell.Hidden = false;

            }
            selectedCell.ColSpan = 1;
        }
    }

    public NumberFormating GetNumberFormating()
    {
        if (selectedCells.Count == 1)
        {
            var cell = selectedCells.Single();
            return cell.NumberFormating;
        }
        return null;
    }

    public void SetFormating(NumberFormating formating)
    {
        foreach(var cell in selectedCells)
            cell.NumberFormating = formating;
    }

    public bool CanUnmerge()
    {
        if (selectedCells.Count != 1)
            return false;
        var cell = selectedCells.First();
        return cell.ColSpan > 1 || cell.RowSpan > 1;
    }

    public void MergeSelectedCells()
    {
        bool sameRow, sameCol;
        var result = CanMerge(out sameRow, out sameCol);
        if (result)
        {
            if (sameRow)
            {
                var min = selectedCells.Min(t => t.ColIndex);
                var row = Data.Rows.ElementAt(selectedCells.First().Row.RowIndex - 1);
                var index = 1;
                foreach (var cell in row.Cells)
                {
                    if (index == min)
                        cell.ColSpan = selectedCells.Count;
                    else if (selectedCells.Any(t => t.ColIndex == index))
                        cell.Hidden = true;
                    index++;
                }
            }
            if (sameCol)
            {
                var min = selectedCells.Min(t => t.Row.RowIndex);
                var col = selectedCells.First().ColIndex - 1;
                var index = 1;
                foreach (var row in Data.Rows)
                {
                    if (index == min)
                        row.Cells.ElementAt(col).RowSpan = selectedCells.Count;
                    else if (selectedCells.Any(t => t.Row.RowIndex == index))
                        row.Cells.ElementAt(col).Hidden = true;
                    index++;
                }
            }
        }
    }

    public bool CanMerge(out bool sameRow, out bool sameCol)
    {
        sameRow = true;
        sameCol = true;
        if (selectedCells.Count < 2)
            return false;
        if (selectedCells.Max(t => t.RowSpan) > 1 || selectedCells.Max(t => t.ColSpan) > 1)
            return false;
        var firstCell = selectedCells.First();
        foreach (var cell in selectedCells)
        {
            if (cell.Row.RowIndex != firstCell.Row.RowIndex)
            {
                sameRow = false;
                break;
            }
        }
        foreach (var cell in selectedCells)
        {
            if (cell.ColIndex != firstCell.ColIndex)
            {
                sameCol = false;
                break;
            }
        }
        if (sameCol)
        {
            /// difrent max and min should be equal with selected cells count
            var difrent = selectedCells.Max(t => t.Row.RowIndex) - selectedCells.Min(t => t.Row.RowIndex) + 1;
            if (difrent == selectedCells.Count)
                return true;
        }
        if (sameRow)
        {
            var difrent = selectedCells.Max(t => t.ColIndex) - selectedCells.Min(t => t.ColIndex) + 1;
            if (difrent == selectedCells.Count)
                return true;
        }
        return false;
    }
    #endregion

    protected override void OnInitialized()
    {
        selectedCells = new List<TableCell>();
        base.OnInitialized();
    }

    void SelectTableCell(bool ctrKey, TableCell cell)
    {
        if (ctrKey)
        {
            if (selectedCells.Contains(cell))
                selectedCells.Remove(cell);
            else
                selectedCells.Add(cell);
        }
        else
        {
            selectedCells.Clear();
            selectedCells.Add(cell);
        }
        Bound.ResetBond();
        Bound.DisableSelection();
        Bound.Page.SelectTable(this);
    }

    public string GetCursor(double x, double y)
    {
        if (Bound.Page.SelectedTable == this)
        {
            if (y > Data.Top && y < Data.Top + 20)
            {
                var leftColl = Data.Left + 15;
                if (Math.Abs(leftColl - x) < 6)
                    return "col-resize";
                foreach (var cel in Data.HeaderCells)
                {
                    leftColl += cel.Width;
                    if (Math.Abs(leftColl - x) < 6)
                        return "col-resize";
                }
            }
            if (x > Data.Left && x < Data.Left + 15)
            {
                var topRow = Data.Top + 20;
                foreach (var row in Data.Rows)
                {
                    topRow += row.Height;
                    if (Math.Abs(topRow - y) < 5)
                        return "row-resize";
                }
            }
        }
        return "default";
    }

    public void DragStart(double x, double y)
    {
        if (Bound.Page.SelectedTable == this)
        {
            changeKind = null;
            ///Column resize
            if (y > Data.Top && y < Data.Top + 20)
            {
                var leftCell = Data.Left + 15;
                if (Math.Abs(leftCell - (int)x) < 6)
                {
                    changeKind = ChangeKind.ColumnResize;
                    changeColIndex = 1;
                    difrentCurcer = leftCell - (int)x;
                }
                var index = 2;
                foreach (var cel in Data.HeaderCells)
                {
                    leftCell += cel.Width;
                    if (Math.Abs(leftCell - (int)x) < 6)
                    {
                        changeKind = ChangeKind.ColumnResize;
                        changeColIndex = index;
                        difrentCurcer = leftCell - (int)x;
                    }
                    index++;
                }

            }
            ///row resize
            if (x > Data.Left && x < Data.Left + 15)
            {
                var topRow = Data.Top + 20;
                var index = 1;
                foreach (var row in Data.Rows)
                {
                    topRow += row.Height;
                    if (Math.Abs(topRow - y) < 5)
                    {
                        changeKind = ChangeKind.RowResize;
                        changeRowIndex = index;
                    }
                    index++;
                }
            }
        }
        else
            changeKind = null;
        /// column resize
        if (changeKind == ChangeKind.ColumnResize)
        {
            xStart = (int)x;
            leftStart = (int)Data.Left;
            if (changeColIndex.Value == 1) // first column
                rightCellStartWidth = Data.HeaderCells.ElementAt(changeColIndex.Value - 1).Width;
            else if (changeColIndex.Value == Data.HeaderCells.Count + 1)
            {
                //last column
                leftCellStartWidth = Data.HeaderCells.ElementAt(changeColIndex.Value - 2).Width;
            }
            else
            {
                //others columns
                leftCellStartWidth = Data.HeaderCells.ElementAt(changeColIndex.Value - 2).Width;
                rightCellStartWidth = Data.HeaderCells.ElementAt(changeColIndex.Value - 1).Width;
            }
            Bound.DisableSelection();
        }
        else if (changeKind == ChangeKind.RowResize)
        {
            yStart = (int)y;
            heightStart = Data.Rows.ElementAt(changeRowIndex.Value - 1).Height;
            Bound.DisableSelection();

        }
    }

    public void Drag(double x, double y)
    {
        if (changeKind == null)
            return;

        if (changeKind == ChangeKind.ColumnResize)
        {
            var actualLeft = GetCellLeftLocation();
            int left;
            Bound.ShowRuler(this, (int)x, out left);
            var dif = xStart.Value - left;
            dif += difrentCurcer.Value;
            if (changeColIndex.Value == 1)
            {
                Data.HeaderCells.ElementAt(changeColIndex.Value - 1).Width = rightCellStartWidth.Value + 2 * dif;
                Data.Left = leftStart.Value - dif;
            }
            else if (changeColIndex.Value == Data.HeaderCells.Count + 1)
            {
                Data.HeaderCells.ElementAt(changeColIndex.Value - 2).Width = leftCellStartWidth.Value - 2 * dif;
                Data.Left = leftStart.Value + dif;
            }
            else
            {
                Data.HeaderCells.ElementAt(changeColIndex.Value - 1).Width = rightCellStartWidth.Value + dif;
                Data.HeaderCells.ElementAt(changeColIndex.Value - 2).Width = leftCellStartWidth.Value - dif;
            }
        }
        else
        {
            var dif = yStart.Value - (int)y;
            Data.Rows.ElementAt(changeRowIndex.Value - 1).Height = heightStart.Value - dif;
        }
    }

    void UpdateTableLocation()
    {
        if (Data.BondType.HasValue)
        {
            var data = Bound.GetBondData(Data.BondType.Value);
            Data.Left = Convert.ToInt32(data.Left + (Bound.ColumnWidth - TableWidth - 15) / 2);
            Data.Top = Convert.ToInt32(data.Top);
        }
    }

    int GetCellLeftLocation()
    {
        var total = Data.Left + 15;
        var index = 1;
        foreach(var cel in Data.HeaderCells)
        {
            if (index < changeColIndex)
                total += cel.Width;
            index++;
        }
        return total;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            UpdateTableLocation();
            StateHasChanged();
        }
        await base.OnAfterRenderAsync(firstRender);
    }

    int TableWidth
    {
        get
        {
            var total = 15;
            foreach (var cell in Data.HeaderCells)
                total += cell.Width;
            return total;
        }
    }
}
